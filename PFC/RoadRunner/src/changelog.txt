DUDAS
=====
* isNext hace internamente un next si es true, pero y sino tambien?
* Cuidado con "#VAR".match("texto") y "texto".match("#VAR"). Ambos hacen match, 
pero si estoy comparando dos Wrapper tendria que modificar el wrapper sobre el que comparo para que tenga "#VAR" y no "text"
* Cuidado con los Contents de los items porque no es lo mismo Text="+" que Plus="+", salvo que pongamos &+; en el plus o tengamos espcial cuidao
* Lo mismo seria mas potito crear el token EOF
* ¿Quien lanzaba un operador primero en el wrapper y luego en el sample? ¿Operator? Si es asi hay que corregirlo
* ¿HOOK NUNCA PUEDE TENER REPARACIONES INTERNAS?
* isWellFormed en una unica direccion?
* ¿como trata el search los #vARIABLE?

CORREGIR
========
* Los iteradores deberian permitir el constructor vacio y que en dicho caso se comience desde la raiz real.
* Si se une variable y text, el mismatch entonces no debe tener un item, sino otro token

TODO
====
* Smtree.clone Smtree.equals ¿Smtree.node.equals?
* !!! Hacer un previous y quiza un isPrevious() para el wrapper
* Estaria bien unos metodos que te dieran tanto en el sample como en el wrapper el siguiente y el anterior elemento a uno dado
sin necesidad de tener que crear un iterador pq solo quieres un elemento que es su vecino

09-06-2008
==========
[S 13:00] Tanto wrapper como sample tienen su propio metodo isWellFormed
[S 12:00] Nuevos constructores para Wrapper: miratelos que son para no tener que 
manejar arboles SMTree en los operadores. Por ejemplo:
            Token newToken = new Variable();
            reparacion.setReparator(new Wrapper(new SMTree<Item>(newToken)));
      Ahora seria:
            reparacion.setReparator(new Wrapper(new Variable()));
[S 11:30] Wrapper.search(...) y Sample.search(...)
[S 10:00] Correccion en el diseño: Text y Variable ya no son directamente Items, sino que heredan de Tokens que a su vez son Items
[S 09:30] Correcciones en Text y Variable
[S 09:30] Token pasa a ser abstracta

08-06-2008
==========
[M 14:00] addVariable
[M 13:00] Sample, Wrapper, Operators, Repair y Mismatch: añadidas funciones y visibilidades


07-06-2008
==========
[M 21:00] Repair. Retoques en iterador del sample, del wrapper.
[S 21:00] Operator, IOperator y sacar las  Enum fuera de Ioperator
[S 17:00] Movido Token a paquete roadrunner.node
[S 16:00] Token casi listo. Modificaciones en Item

06-06-2008
==========
[S 20:00] Wrapper casi listo, pero con muchos errores a falta de decidir que hacemos con Sample/token y corregir los Iteradores

03-03-2008
==========
[M XX:XX] Items: Token, tupla, etc.

31-05-2008
==========
[M 02:00] Iteradores


30-05-2008
==========
[M 23:59] Pruebas hechas
[S 23:59] Casi finiquitado SMTree
[S 17:00] Modificado SMTreeNode.equals: tambien considera referencias
[S 16:40] Añadido metodo RR.debug()

28-05-2008
==========
[S 19:00] Varios cambios en clases SMTree*
[S 17:35] Modificado SMTree.setRootObject(T o) y SMTree.setRoot(val). OJO con actualizar el mapa...
[S 17:30] Añadido constructor vacio SMTree()
[S 17:00] Rehaciendo el changelog a un formato ameno e intuitivo :b

27-05-2008
==========
[M 20:00] SMTree comenzado.
[M 20:00] SMTreeNode finalizado pero con dudas.
[M 20:00] SMIndexStructure: finalizado
[S 14:00] Nuevo constructor: public SMTreeNode(T o, SMTreeNode parent, SMTreeNode nextSibling, SMTreeNode previousSibling, SMTreeNode firstChild)


DUDAS SOLUCIONADAS
==================

[M 28-05-08] ¿Clone debe clonar también las referencias? Eso añadiría complejidad ya que es fácil entrar en un bucle infinito.
            ·[S] No, desde el punto de vista de un nodo no es responsabilidad suya clonar las referencias
                Seria responsabilidad de SMTree que es quien ve a los nodos como una estructura arbórea.
[M 28-05-08] ¿Debe equals comparar también las referencias?
            ·[S] Yo diría que sí. Aún así lo mismo vendría bien un método aparte que te comparase si el objeto del nodo es igual(por referencia y/o por objeto en sí) a un objeto dado.

[M 28-05-08] ¿Debe equals utilizar el hashcode y ya está? (está generado con un asistente que tiene en cuenta todos los atributos del nodo)
            ·[S] "Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes."
                    Viendo esa frase de internet, que es cierta, tengo dudas. ¿buscamos una comparación exacta o algo mas rápido?

CORRECCIONES HECHAS
===================

